'''
iterator(반복자)

for i in range(100):은 0부터 99까지 연속한 숫자를 만들어낸다고 했는데, 
사실은 숫자를 모두 만들어 내는 것이 아니라 0부터 99까지 값을 차례대로 꺼낼 수 있는 이터레이터를 하나만 만들어냅니다.
이후 반복할 때마다 이터레이터에서 숫자를 하나씩 꺼내서 반복합니다.
연속한 숫자를 미리 만들면 숫자가 적을 때는 상관없지만 숫자가 아주 많을 때는 메모리를 많이 사용하므로 성능에도 불리합니다. 
그래서 파이썬에서는 이터레이터만 생성하고 값이 필요한 시점이 되었을 때 값을 만드는 방식을 사용합니다. 
즉, 데이터 생성을 뒤로 미루는 것인데 이런 방식을 지연 평가(lazy evaluation)라고 합니다.


iterable(반복 가능 객체) - 요소가 여러개, 한번에 하나씩 꺼내기 가능. ex)문자열, 리스트, 딕셔너리, 세트

객체가 iterable인지 확인하려면
-> 내장함수 dir( 객체가 자체적으로 가지고 있는 변수나 함수를 보여 준다. )로 __iter__ 메서드 유무 체크로 가능.
'''
#print(dir([1,2,3]))
#print(dir((1,2,3)))
#print(dir({'a','b','c'}))
#print(dir({'a':1, 2:True, False:'ccc'}))



#__iter__ 호출
it = [1,2,3].__iter__()
print(it)
# iterator 변수 저장 후__next__ 메서드를 호출해보면 요소를 차례대로 꺼낼 수 있음.
print(it.__next__())
print(it.__next__())
print(it.__next__())
#print(it.__next__()) # 더 이상 꺼낼 요소 없는 경우  StopIteration 예외 발생.


#리스트뿐만 아니라 문자열, 딕셔너리, 세트도 __iter__를 호출하면 이터레이터 객체 나옴.
'Hello, world!'.__iter__()
{'a': 1, 'b': 2}.__iter__()
{1, 2, 3}.__iter__()


#range 의경우
it = range(3).__iter__()
print(it.__next__())
print(it.__next__())
print(it.__next__())


# __iter__, __next__를 가진 객체를 이터레이터 프로토콜(iterator protocol)을 지원한다고 말합니다.
#반복 가능한 객체는 요소를 한 번에 하나씩 가져올 수 있는 객체이고, 
#이터레이터는 __next__ 메서드를 사용해서 차례대로 값을 꺼낼 수 있는 객체입니다. 
#반복 가능한 객체와 이터레이터는 별개의 객체이므로 둘은 구분해야 합니다. 
#즉, 반복 가능한 객체에서 __iter__ 메서드로 이터레이터를 얻습니다.